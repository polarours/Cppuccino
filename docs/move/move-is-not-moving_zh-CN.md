[中文](move-is-not-moving_zh-CN.md) | [English](move-is-not-moving.md)

# std::move 并不会“移动”任何东西

## 核心观点

`std::move` 本身**不执行移动操作**。
它唯一的作用，是将一个表达式无条件地转换为**右值引用**，从而**允许**后续代码选择移动语义。

是否真的发生“移动”，完全取决于：
- 对象的类型
- 是否存在可用的移动构造 / 移动赋值
- 当前上下文是否允许调用它们

`std::move` 只是打开了一扇门，本身什么也没搬走。

> **提示**: 关于右值引用的详细解释，请参考相关章节（待补充）

## 常见误解

很多人（包括刚开始学的我）会下意识地认为：

```cpp
std::move(a); // a 已经被移动走了
```

实际上，`std::move` 并不会改变 `a` 的状态或内容。
真正发生移动的是移动构造函数或移动赋值运算符，而不是 `std::move` 本身。

## 那 std::move 真正做了什么？
从语义上讲，`std::move` 的实现非常简单，类似于下面的代码：

```cpp
template <typename T>
typename std::remove_reference<T>::type&& move(T&& t) noexcept {
    return static_cast<typename std::remove_reference<T>::type&&>(t);
}
```

也就是说：
- 它不关心对象当前的状态
- 它只是将传入的对象 `t` 强制转换为右值引用类型
- 不保证任何资源的转移或释放
    
它只是告诉编译器：“我允许你把这个左值，当成一个即将被放弃的对象来看待。”

## 示例说明

```cpp 
std::string str = "Hello, World!";
std::string movedStr = std::move(str); // 这里调用了 std::string 的移动构造函数
```

这中间发生了什么？
1. `std::move(str)` 将 `str` 转换为 `std::string&&`（右值引用）。
2. 由于 `std::string` 有一个移动构造函数，编译器选择调用它，将 `str` 的资源“移动”到 `movedStr`。
3. `str` 现在处于一个有效但未定义的状态（通常是空字符串）。

移动不是语言行为，而是类型行为。

## move 之后的对象状态
使用 `std::move` 后，原对象的状态取决于其类型的移动语义。

- 对于标准库类型（如 `std::string`、`std::vector` 等），移动后通常会将资源的所有权转移到新对象，原对象变为空或处于某种“有效但未定义”的状态。
- 对于自定义类型，移动后的状态完全取决于你如何实现移动构造函数和移动赋值运算符。

例如：
```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};
std::vector<int> movedVec = std::move(vec);
// vec 仍然有效，但内容可能已被移动（通常为空）。
```
> **提示**: 更详细的 `move` 过程和所有权的介绍，请参考后面的章节（待补充）。

---

## 重要提示

- `std::move` 本身不会改变对象状态，它只允许移动语义发生。原对象仍然有效，但状态可能未定义或为空，取决于类型的移动实现。
- 仅在确实需要移动资源时使用 `std::move`，避免不必要的复杂性和潜在错误。
- 它是一个类型转换工具，不会自动释放或转移资源。
